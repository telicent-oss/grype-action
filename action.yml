name: Grype Scan Action
description: |
  This action scans a filesystem/SBOM/Container Image using Grype
author: Telicent
branding:
  icon: 'lock'
  color: 'green'
inputs:
  scan-ref:
    required: true
    description: |
      The reference to the filesystem path, SBOM file, or container image to scan
  scan-name:
    required: true
    description: |
      A unique name for the scan to disambiguate the Job Artifacts it creates from 
      others created by the same workflow.

      Note that the given `scan-name` value will be sanitised to remove characters that are 
      not permitted by the actions that consume this value.  You can find the actual names
      used for the report files and artifacts in the action output.
  scan-type:
    required: true
    description: |
      Specifies the kind of grype scan to perform, one of `image`, `fs` or `sbom`.  Other
      values are not currently supported and will cause the action to fail.
  remote-vex:
    required: false
    default: ""
    description: |
      Specifies a new line separated list of remote repositories whose VEX statements should be
      retrieved via sparse checkout of their .vex/ directory.  These VEX statements will be used 
      to augment any local VEX statements in the .vex/ directory when scanning for vulnerabilities.
  gh-token:
    required: false
    default: ${{ github.token }}
    description: |
      A GitHub Token needed to determine the current grype database version for caching.
      Defaults to `github.token` which is the token for this build, can be overridden if this default token doesn't work
      for your build environment.
  gh-user:
    required: false
    default: ${{ github.actor }}
    description: |
      A GitHub User to use when cloning remote repositories to retrieve remote VEX statements.

      Defaults to `github.actor` which is the user running the build, can be overridden if this default user does not 
      match the user who owns the `gh-token` input e.g. if providing a custom GitHub Token to retrieve VEX statements
      from private repositories.
  allow-unfixed:
    required: false
    default: "false"
    description: |
      Specifies whether it is permitted for the action to pass if it detects High/Critical 
      vulnerabilities that do not currently have a fix i.e. there is not necessarily anything
      we could do to resolve them at this time.
  debug-mode:
    required: false
    default: "true"
    description: |
      Enable debug logging for this action. Set to 'true' to see more verbose output.
outputs:
  scan-results:
    value: ${{ steps.generate-outputs.outputs.scan-results }}
    description: |
      The name of a GitHub Actions Artifact that has been uploaded by this action and contains 
      the full Grype JSON scan results generated by the Grype scan.
  scan-results-file:
    value: ${{ steps.generate-outputs.outputs.scan-results-file }}
    description: |
      The name of the Grype JSON results file contained in the uploaded GitHub Actions artifact.
  scan-results-url:
    value: ${{ steps.generate-outputs.outputs.scan-results-url }}
    description: |
      The URL of the GitHub Actions Artifact that has been uploaded by this action and contains 
      the full Grype JSON scan results generated by the Grype Scan.
runs:
  using: "composite"
  steps:
    - name: Set Debug Environment Variable
      shell: bash
      run: |
        if [ "${{ inputs.debug-mode }}" == "true" ]; then
          echo "::debug::Debug mode enabled."
          echo "DEBUG_MODE=true" >> "$GITHUB_ENV"
        else
          echo "DEBUG_MODE=false" >> "$GITHUB_ENV"
        fi

    - name: Fail on Unsupported Scan Type
      # NB - Can't have an array literal directly in an Actions expression, but can use fromJSON() function 
      #      to parse an array literal on the fly, go figure!
      #      See https://github.com/orgs/community/discussions/27223
      if: ${{ !contains(fromJSON('[ "image", "fs", "sbom" ]'), inputs.scan-type) }}
      shell: sh
      run: |
        echo "::error title=${{ github.job }} - Unsupported Scan Type::Received Scan Type '${{ inputs.scan-type}}' which is not supported"
        exit 1

    # As we're going to use the scan name for both output file names and GitHub Actions Artifacts have to sanitise it
    # to remove characters that are disallowed, or would cause those usages to break
    #
    # For GitHub Actions Artifacts this is as follows:
    # 
    # Double quote ", Colon :, Less than <, Greater than >, Vertical bar |, Asterisk *, Question mark ?, Carriage 
    # return \r, Line feed \n, Backslash \, Forward slash /
    #
    # These characters are not allowed in the artifact name due to limitations with certain file systems such as NTFS. 
    # To maintain file system agnostic behavior, these characters are intentionally not allowed to prevent potential 
    # problems with downloads on different file systems.

    - name: Sanitise Scan name
      id: sanitised
      shell: bash
      run: |
        if [ "$DEBUG_MODE" == "true" ]; then
          echo "::debug::Input scan-name: ${{ inputs.scan-name }}"
          echo "::debug::Input scan-ref: ${{ inputs.scan-ref }}"
        fi
        base='${{ inputs.scan-name }}'
        # Clean characters disallowed by artifact names
        safe_base="$(printf '%s' "$base" | tr -d '\r\n' | sed -E 's/["<>:|*?\\\/]/-/g' | tr -s '-')"
        
        # Make a deterministic unique suffix for this invocation
        ref_hash="$(printf '%s' '${{ inputs.scan-ref }}' | sha256sum | cut -c1-8)"
        run_part="${{ runner.name }}-${{ github.run_id }}-${{ github.run_attempt }}"
        
        # Keep filenames readable; only the artifact name needs to be unique
        echo "file_prefix=$safe_base" >> "$GITHUB_OUTPUT"
        echo "artifact_name=$(printf '%s-%s-%s' "$safe_base" "$run_part" "$ref_hash" | sed -E 's/["<>:|*?\\\/]/-/g' | tr -s '-')" >> "$GITHUB_OUTPUT"
        
        if [ "$DEBUG_MODE" == "true" ]; then
          echo "::debug::Sanitised file_prefix: $safe_base"
          echo "::debug::Generated artifact_name: $(cat "$GITHUB_OUTPUT" | grep artifact_name | cut -d'=' -f2)"
        fi

    - name: Merge VEX Statements
      id: merge-vex
      uses: telicent-oss/merge-vex-action@v1
      with:
        name: ${{ inputs.scan-name }}-for-grype
        remote-vex: ${{ inputs.remote-vex }}
        # Pass debug-mode to the sub-action if it supports it, otherwise log here
        debug-mode: ${{ inputs.debug-mode }} # Assuming the sub-action supports a debug-mode input

    - name: Generate Grype Ignore file
      id: generate-grype-config
      if: ${{ steps.merge-vex.outputs.prepared == 'true' }}
      shell: bash
      run: |
        if [ "$DEBUG_MODE" == "true" ]; then
          echo "::debug::Attempting to generate Grype configuration from VEX statements."
          echo "::debug::VEX file location: ${{ steps.merge-vex.outputs.vex-file }}"
        fi
        cat ${{ steps.merge-vex.outputs.vex-file }} | yq '.statements[] | select(.status == "not_affected") | { "ignore": [ { "vulnerability": .vulnerability.name, "reason": "${{ steps.merge-vex.outputs.vex-file-name }}: \(.justification)" } ] } | . as $item ireduce({}; . *+ $item)' > .grype.yaml.generated

        if [ "$DEBUG_MODE" == "true" ]; then
          echo "Generated Grype Configuration is as follows:"
          cat .grype.yaml.generated
        fi

        if [ -f ".grype.yaml" ]; then
          echo "Merging Grype Configuration files..."
          cp -v .grype.yaml .grype.yaml.original
          yq eval-all '. as $item ireduce ({}; . *+ $item )' .grype.yaml.original .grype.yaml.generated > .grype.yaml.merged
          cp -fv .grype.yaml.merged .grype.yaml
          if [ "$DEBUG_MODE" == "true" ]; then
            echo "Merged Grype configuration file is as follows:"
            cat .grype.yaml
          fi
        else
          cp -v .grype.yaml.generated .grype.yaml
          if [ "$DEBUG_MODE" == "true" ]; then
            echo "::debug::No existing .grype.yaml found. Using generated file as .grype.yaml."
          fi
        fi
        echo ""

    - name: Setup Grype
      id: setup-grype
      uses: anchore/scan-action/download-grype@v7.1.0
      with:
        grype-version: v0.102.0
        cache-db: true

    # Perform a full vulnerability to generate a full vulnerability report
    - name: Grype Vulnerability Scan
      uses: anchore/scan-action@v7.1.0
      with:
        # Annoyingly Grype's action has separate input for each supported scan type, so use some GitHub Actions
        # expressions to either populate/blank each possible input as appropriate
        image: ${{ inputs.scan-type == 'image' && inputs.scan-ref || '' }}
        path: ${{ inputs.scan-type == 'fs' && inputs.scan-ref || '' }}
        sbom: ${{ inputs.scan-type == 'sbom' && inputs.scan-ref || '' }}
        # Specify the location for the output
        output-file: ${{ runner.temp }}/${{ steps.sanitised.outputs.file_prefix }}-grype-report.json
        output-format: json
        # Don't want to fail the build yet, just getting the full report for now
        fail-build: false
        # Restore the Cached Grype vulnerability database
        grype-version: v0.92.2
        cache-db: true

    - name: Upload Vulnerability Scan Results
      id: upload-scan-results
      uses: actions/upload-artifact@v4.6.2
      with:
        name: ${{ steps.sanitised.outputs.artifact_name }}
        path: ${{ runner.temp }}/${{ steps.sanitised.outputs.file_prefix }}-grype-report.json
        retention-days: 30
        overwrite: true

    - name: Log Artifact Details (Debug)
      if: ${{ env.DEBUG_MODE == 'true' }}
      shell: bash
      run: |
        echo "::debug::Uploaded Artifact Name: ${{ steps.sanitised.outputs.artifact_name }}"
        echo "::debug::Artifact Path: ${{ runner.temp }}/${{ steps.sanitised.outputs.file_prefix }}-grype-report.json"
        echo "::debug::Artifact URL: ${{ steps.upload-scan-results.outputs.artifact-url }}"

    - name: Register Scan Results as Action Output
      shell: sh
      id: generate-outputs
      run: |
        echo "scan-results=${{ steps.sanitised.outputs.artifact_name }}-grype-report" >> $GITHUB_OUTPUT
        echo "scan-results-file=${{ steps.sanitised.outputs.file_prefix }}-grype-report.json" >> $GITHUB_OUTPUT
        echo "scan-results-url=${{ steps.upload-scan-results.outputs.artifact-url }}" >> $GITHUB_OUTPUT

    - name: Get Report template
      uses: actions/checkout@v4
      with:
        repository: telicent-oss/grype-action
        ref: main
        sparse-checkout: |
          report-template.tpl
        sparse-checkout-cone-mode: false
        path: .grype-templates/

    - name: Fail build on High/Criticial Vulnerabilities
      id: gating-scan
      uses: anchore/scan-action@v7.1.0
      with:
        # Annoyingly Grype's action has separate input for each supported scan type, so use some GitHub Actions
        # expressions to either populate/blank each possible input as appropriate
        image: ${{ inputs.scan-type == 'image' && inputs.scan-ref || '' }}
        path: ${{ inputs.scan-type == 'fs' && inputs.scan-ref || '' }}
        sbom: ${{ inputs.scan-type == 'sbom' && inputs.scan-ref || '' }}
        # Specify the location for the output
        output-file: ${{ runner.temp }}/${{ steps.sanitised.outputs.file_prefix }}-grype-gating-report.json
        output-format: json
        # Fail build on HIGH/CRITICAL
        severity-cutoff: high
        fail-build: true
        only-fixed: ${{ inputs.allow-unfixed }}
        # Restore the Cached Grype vulnerability database
        grype-version: v0.102.0
        cache-db: true

    - name: Display Gating Vulnerabilities in Job Summary (if any)
      if: ${{ always() }}
      shell: bash
      run: |
        if [ "$DEBUG_MODE" == "true" ]; then
          echo "::debug::Checking if gating report file exists: ${RUNNER_TEMP}/${{ steps.sanitised.outputs.file_prefix }}-grype-gating-report.json"
        fi

        if [ -f "${RUNNER_TEMP}/${{ steps.sanitised.outputs.file_prefix }}-grype-gating-report.json" ]; then
          echo "# Grype \`${{ inputs.scan-type }}\` scan on \`${{inputs.scan-ref }}\`" >> "$GITHUB_STEP_SUMMARY"
          SCAN_ARG=""
          case "${{ inputs.scan-type }}" in
            image)
              SCAN_ARG="docker:${{ inputs.scan-ref }}"
              ;;
            fs)
              if [ -d "${{ inputs.scan-ref }}" ]; then
                SCAN_ARG="dir:${{ inputs.scan-ref }}"
              else
                SCAN_ARG="file:${{ inputs.scan-ref }}"
              fi
              ;;
            sbom)
              SCAN_ARG="sbom:${{ inputs.scan-ref }}"
              ;;
            *)
              echo "::error title=${{ github.job }} - Unsupported Grype Scan Type::Received Grype Scan Type '${{ inputs.scan-type}}' which is not supported"
              exit 1
              ;;
          esac
          if [ "$DEBUG_MODE" == "true" ]; then
             echo "::debug::Grype command being run for job summary: ${{ steps.setup-grype.outputs.cmd }} $SCAN_ARG --output template --template .grype-templates/report-template.tpl"
          fi
          echo "Running grype again to generate job summary"
          ${{ steps.setup-grype.outputs.cmd }} $SCAN_ARG --output template \
            --template .grype-templates/report-template.tpl >> "$GITHUB_STEP_SUMMARY"
        fi

    - name: Add Error to Build if Scan Failed
      if: ${{ failure() && steps.gating-scan.outcome == 'failure' }}
      shell: sh
      run: |
        if [ "$DEBUG_MODE" == "true" ]; then
          echo "::debug::Gating scan failed, adding final error annotation."
        fi
        echo "::error title=${{ github.job }} - High/Critical Vulnerabilities Found::Grype detected HIGH/CRITICAL vulnerabilities scanning ${{ inputs.scan-ref }}, please review the report and apply relevant fixes.  Report is attached as build artifact ${{ steps.sanitised.outputs.artifact_name }}-grype-report and rendered as a human readable job summary."

    - name: Cleanup .grype-templates/
      if: ${{ always() }}
      shell: bash
      run: |
        if [ "$DEBUG_MODE" == "true" ]; then
          echo "::debug::Starting cleanup process."
        fi
        # Remove Grype report templates
        rm -Rf .grype-templates/

        # Removed generated and merged Grype files if present
        rm -f .grype.yaml.generated .grype.yaml.merged

        # Restore original Grype configuration file if exists
        if [ -f .grype.yaml.original ]; then
          mv -fv .grype.yaml.original .grype.yaml
        fi
        
